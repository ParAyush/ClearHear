import os
import re
from io import BytesIO

import streamlit as st
from docx import Document
from docx.enum.text import WD_COLOR_INDEX, WD_BREAK
from docx.shared import RGBColor

from audio import analyze_audio_file


st.set_page_config(page_title="ClearHear – Dual Transcript", layout="wide")
st.title("ClearHear Audio – Accessible Notes From Conversations")

st.markdown(
    """
Upload a recording of a conversation or lecture (audio only).  

ClearHear will generate:

1. A **raw transcript**  
2. **Accessible notes**  

Downloadable as .txt or .docx.
"""
)

try:
    key = st.secrets.get("GEMINI_API_KEY", None)
except Exception:
    key = None

if not key:
    key = os.getenv("GEMINI_API_KEY")

GEMINI_API_KEY = key


def build_legend_page(doc: Document):
    doc.add_heading("ClearHear – Legend", level=1)
    doc.add_paragraph(
        "This document was generated by ClearHear to support hard-of-hearing and deaf students."
    )

    doc.add_heading("Tag Explanations", level=2)
    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("[T=MM:SS–MM:SS] ").bold = True
    bullet.add_run("Time in audio.")

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("[Speaker: ROLE] ").bold = True
    bullet.add_run("Who is speaking.")

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("[TONE: tone_word] ").bold = True
    bullet.add_run("Emotional tone.")

    doc.add_heading("Formatting", level=2)

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("Highlighted definitions ").bold = True
    example = bullet.add_run("Definition – TERM")
    example.bold = True
    example.font.highlight_color = WD_COLOR_INDEX.YELLOW

    pb_para = doc.add_paragraph()
    pb_para.add_run().add_break(WD_BREAK.PAGE)


def add_markdown_runs(paragraph, text: str):
    parts = re.split(r"(\*\*.*?\*\*)", text)
    for part in parts:
        if part.startswith("**") and part.endswith("**"):
            paragraph.add_run(part[2:-2]).bold = True
        else:
            paragraph.add_run(part)


def highlight_definitions(paragraph):
    for run in paragraph.runs:
        if "Definition –" in run.text:
            run.font.highlight_color = WD_COLOR_INDEX.YELLOW


def style_important_words(paragraph):
    keywords = [
        "important", "key concept", "exam", "midterm", "final",
        "test", "deadline", "assignment", "definition", "Definition –"
    ]
    for run in paragraph.runs:
        if any(k in run.text.lower() for k in keywords):
            run.bold = True


def style_tone_and_speaker(paragraph):
    tone_colors = {
        "urgent": RGBColor(220, 20, 60),
        "excited": RGBColor(255, 140, 0),
        "calm": RGBColor(56, 189, 248),
        "friendly": RGBColor(16, 185, 129),
        "frustrated": RGBColor(147, 51, 234),
        "sad": RGBColor(59, 130, 246),
        "angry": RGBColor(178, 34, 34),
        "joking": RGBColor(234, 179, 8),
        "uncertain": RGBColor(107, 114, 128),
        "neutral": RGBColor(148, 163, 184),
    }

    for run in list(paragraph.runs):
        text = run.text
        paragraph._element.remove(run._element)
        pos = 0
        while pos < len(text):
            tm = re.search(r"\[TONE:\s*([^\]]+)\]", text[pos:])
            sm = re.search(r"\[Speaker:[^\]]+\]", text[pos:])
            cands = []
            if tm: cands.append(("tone", tm.start(), tm))
            if sm: cands.append(("speaker", sm.start(), sm))
            if not cands:
                paragraph.add_run(text[pos:])
                break
            typ, rel, m = sorted(cands, key=lambda x: x[1])[0]
            start = pos + rel
            end = start + len(m.group(0))
            if start > pos:
                paragraph.add_run(text[pos:start])
            r = paragraph.add_run(text[start:end])
            r.bold = True
            if typ == "tone":
                color = tone_colors.get(m.group(1).strip().lower(), RGBColor(148, 163, 184))
                r.font.color.rgb = color
            pos = end

    highlight_definitions(paragraph)
    style_important_words(paragraph)


def notes_to_docx(accessible_notes: str) -> BytesIO:
    doc = Document()
    build_legend_page(doc)
    lines = accessible_notes.splitlines()
    first = False
    for line in lines:
        s = line.rstrip("\n")
        if not s.strip():
            doc.add_paragraph()
            continue
        if s.startswith("### "):
            if first:
                pb = doc.add_paragraph()
                pb.add_run().add_break(WD_BREAK.PAGE)
            first = True
            doc.add_heading(s[4:].strip(), level=3)
            continue
        if s.startswith("## "):
            doc.add_heading(s[3:].strip(), level=2)
            continue
        if s.startswith("# "):
            doc.add_heading(s[2:].strip(), level=1)
            continue
        if s.lstrip().startswith("- "):
            t = s.lstrip()[2:]
            p = doc.add_paragraph(style="List Bullet")
            add_markdown_runs(p, t)
            style_tone_and_speaker(p)
            continue
        p = doc.add_paragraph()
        add_markdown_runs(p, s)
        style_tone_and_speaker(p)

    buf = BytesIO()
    doc.save(buf)
    buf.seek(0)
    return buf


uploaded_audio = st.file_uploader(
    "Upload an audio file (.wav, .mp3, .m4a, .ogg)",
    type=["wav", "mp3", "m4a", "ogg"]
)

if not GEMINI_API_KEY:
    st.error("Gemini key missing.")
    st.stop()

if uploaded_audio:
    file_extension = uploaded_audio.name.split(".")[-1]
    temp_path = f"temp_upload.{file_extension}"
    with open(temp_path, "wb") as f:
        f.write(uploaded_audio.read())
    with st.spinner("Generating notes…"):
        try:
            result = analyze_audio_file(temp_path, GEMINI_API_KEY)
        finally:
            try: os.remove(temp_path)
            except: pass

    raw = result.get("raw_transcript", "").strip()
    acc = result.get("accessible_transcript", "").strip()

    st.subheader("Download Options")
    c1, c2, c3 = st.columns(3)

    with c1:
        st.download_button("Raw (.txt)", raw, "raw.txt")
    with c2:
        st.download_button("Accessible (.txt)", acc, "accessible.txt")
    with c3:
        st.download_button("Accessible (.docx)", notes_to_docx(acc).getvalue(), "accessible.docx")

    st.markdown("---")

    T1, T2 = st.tabs(["Raw Transcript", "Accessible Notes"])

    with T1:
        st.write(raw)

    with T2:
        st.write(acc)

else:
    st.info("Upload an audio file to begin.")
