import os
import re
from io import BytesIO

import streamlit as st
from docx import Document
from docx.enum.text import WD_COLOR_INDEX, WD_BREAK
from docx.shared import RGBColor

from audio import analyze_audio_file


st.set_page_config(page_title="ClearHear – Dual Transcript", layout="wide")

st.title("ClearHear Audio – Accessible Notes From Conversations")

st.markdown(
    """
Upload a recording of a conversation or lecture (audio only).  

ClearHear will generate:

1. A **raw transcript** – readable version of what was said.  
2. **Accessible notes** – structured, timestamped notes with tone, speakers, quotes, and definitions.  

You can read them here and download them as **.txt** or a nicely formatted **.docx** file.
"""
)

# DONT COMMIT
GEMINI_API_KEY = st.secrets.get("GEMINI_API_KEY", "")



def build_legend_page(doc: Document):
    doc.add_heading("ClearHear – Legend", level=1)

    doc.add_paragraph(
        "This document was generated by ClearHear to support hard-of-hearing and deaf students. "
        "The notes use consistent tags and formatting so you can quickly understand who is speaking, "
        "how they sound, and where in the audio each point occurs."
    )

    doc.add_heading("Tag Explanations", level=2)
    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("[T=MM:SS–MM:SS] ").bold = True
    bullet.add_run("Approximate time range in the audio where this point appears.")

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("[Speaker: ROLE] ").bold = True
    bullet.add_run("Who is speaking, e.g., Professor, Student, Guest.")

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("[TONE: tone_word] ").bold = True
    bullet.add_run(
        "Emotional tone of the speaker, such as calm, excited, urgent, frustrated, joking, etc."
    )

    doc.add_heading("Formatting", level=2)

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("Headings ").bold = True
    bullet.add_run("group related ideas into sections for easier scanning.")

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("Bullet points ").bold = True
    bullet.add_run("summarize each important claim, definition, or example.")

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("Highlighted definitions ").bold = True
    bullet.add_run("show key terms like this: ")
    example = bullet.add_run("Definition – TERM")
    example.bold = True
    example.font.highlight_color = WD_COLOR_INDEX.YELLOW

    bullet = doc.add_paragraph(style="List Bullet")
    bullet.add_run("Tone colors ").bold = True
    bullet.add_run("help you quickly spot emotional cues, e.g., ")
    run = bullet.add_run("[TONE: urgent]")
    run.font.color.rgb = RGBColor(200, 0, 0)

    pb_para = doc.add_paragraph()
    pb_para.add_run().add_break(WD_BREAK.PAGE)


def add_markdown_runs(paragraph, text: str):

    parts = re.split(r"(\*\*.*?\*\*)", text)
    for part in parts:
        if not part:
            continue
        if part.startswith("**") and part.endswith("**"):
            run = paragraph.add_run(part[2:-2])
            run.bold = True
        else:
            paragraph.add_run(part)


def highlight_definitions(paragraph):
    for run in paragraph.runs:
        if "Definition –" in run.text:
            run.font.highlight_color = WD_COLOR_INDEX.YELLOW


def style_important_words(paragraph):

    important_keywords = [
        "important",
        "key concept",
        "key idea",
        "key term",
        "remember",
        "exam",
        "midterm",
        "final",
        "test",
        "deadline",
        "assignment",
        "definition",
        "Definition –",
        "main point",
        "takeaway",
    ]

    for run in paragraph.runs:
        text_lower = run.text.lower()
        if not text_lower.strip():
            continue

        if any(k.lower() in text_lower for k in important_keywords):
            run.bold = True

            if any(k in text_lower for k in ["exam", "midterm", "final", "deadline", "test"]):
                run.font.highlight_color = WD_COLOR_INDEX.BRIGHT_GREEN


def style_tone_and_speaker(paragraph):

    tone_colors = {
        "urgent": RGBColor(220, 20, 60),      # red
        "excited": RGBColor(255, 140, 0),     # orange
        "calm": RGBColor(56, 189, 248),       # light blue
        "friendly": RGBColor(16, 185, 129),   # teal/green
        "frustrated": RGBColor(147, 51, 234), # purple
        "sad": RGBColor(59, 130, 246),        # blue
        "angry": RGBColor(178, 34, 34),       # dark red
        "joking": RGBColor(234, 179, 8),      # yellow-ish
        "uncertain": RGBColor(107, 114, 128), # gray
        "neutral": RGBColor(148, 163, 184),   # light gray
    }

    new_runs = []

    for run in list(paragraph.runs):
        text = run.text
        paragraph._element.remove(run._element)

        pos = 0
        while pos < len(text):
            tone_match = re.search(r"\[TONE:\s*([^\]]+)\]", text[pos:])
            speaker_match = re.search(r"\[Speaker:[^\]]+\]", text[pos:])

            candidates = []
            if tone_match:
                candidates.append(("tone", tone_match.start(), tone_match))
            if speaker_match:
                candidates.append(("speaker", speaker_match.start(), speaker_match))

            if not candidates:
                nr = paragraph.add_run(text[pos:])
                new_runs.append(nr)
                break

            tag_type, rel_start, match_obj = sorted(candidates, key=lambda x: x[1])[0]
            start = pos + rel_start
            end = start + len(match_obj.group(0))

            if start > pos:
                nr = paragraph.add_run(text[pos:start])
                new_runs.append(nr)

            tag_text = text[start:end]
            nr = paragraph.add_run(tag_text)
            nr.bold = True

            if tag_type == "tone":
                tone_word = match_obj.group(1).strip().lower()
                color = tone_colors.get(tone_word, RGBColor(148, 163, 184))
                nr.font.color.rgb = color
            elif tag_type == "speaker":
                nr.font.color.rgb = RGBColor(75, 85, 99)  # darker gray

            new_runs.append(nr)
            pos = end

    highlight_definitions(paragraph)
    style_important_words(paragraph)


def notes_to_docx(accessible_notes: str) -> BytesIO:

    doc = Document()

    # First page: legend
    build_legend_page(doc)

    lines = accessible_notes.splitlines()
    first_section_seen = False

    for line in lines:
        stripped = line.rstrip("\n")

        if not stripped.strip():
            doc.add_paragraph()
            continue


        if stripped.startswith("### "):
            if first_section_seen:
                pb = doc.add_paragraph()
                pb.add_run().add_break(WD_BREAK.PAGE)
            first_section_seen = True
            doc.add_heading(stripped[4:].strip(), level=3)
            continue
        elif stripped.startswith("## "):
            doc.add_heading(stripped[3:].strip(), level=2)
            continue
        elif stripped.startswith("# "):
            doc.add_heading(stripped[2:].strip(), level=1)
            continue

        if stripped.lstrip().startswith("- "):
            text = stripped.lstrip()[2:]
            p = doc.add_paragraph(style="List Bullet")
            add_markdown_runs(p, text)
            style_tone_and_speaker(p)
            continue
        if stripped.lstrip().startswith("* "):
            text = stripped.lstrip()[2:]
            p = doc.add_paragraph(style="List Bullet")
            add_markdown_runs(p, text)
            style_tone_and_speaker(p)
            continue

        p = doc.add_paragraph()
        add_markdown_runs(p, stripped)
        style_tone_and_speaker(p)

    buf = BytesIO()
    doc.save(buf)
    buf.seek(0)
    return buf


# streamlit

uploaded_audio = st.file_uploader(
    "Upload an audio file (.wav, .mp3, .m4a, .ogg)",
    type=["wav", "mp3", "m4a", "ogg"]
)

if not GEMINI_API_KEY:
    st.error("Gemini API key is not set. Configure GEMINI_API_KEY in Streamlit secrets.")
    st.stop()


    file_extension = uploaded_audio.name.split(".")[-1]
    temp_path = f"temp_upload.{file_extension}"

    with open(temp_path, "wb") as f:
        f.write(uploaded_audio.read())

    with st.spinner("Transcribing and generating accessible notes with Gemini…"):
        try:
            result = analyze_audio_file(temp_path, GEMINI_API_KEY)
        finally:
            try:
                os.remove(temp_path)
            except OSError:
                pass

    raw_transcript = result.get("raw_transcript", "")
    accessible_transcript = result.get("accessible_transcript", "")

    if isinstance(raw_transcript, str):
        raw_transcript = raw_transcript.strip()
    else:
        raw_transcript = str(raw_transcript)

    if isinstance(accessible_transcript, str):
        accessible_transcript = accessible_transcript.strip()
    else:
        accessible_transcript = str(accessible_transcript)

    if not raw_transcript and not accessible_transcript:
        st.error("Gemini returned empty transcripts.")
        st.stop()


#download
    st.subheader("Download Options")

    col1, col2, col3 = st.columns(3)

    with col1:
        st.download_button(
            label="⬇️ Download raw transcript (.txt)",
            data=raw_transcript,
            file_name="transcript_raw.txt",
            mime="text/plain",
        )

    with col2:
        st.download_button(
            label="⬇️ Download accessible notes (.txt)",
            data=accessible_transcript,
            file_name="transcript_accessible.txt",
            mime="text/plain",
        )

    with col3:
        docx_buf = notes_to_docx(accessible_transcript)
        st.download_button(
            label="⬇️ Download accessible notes (.docx)",
            data=docx_buf.getvalue(),
            file_name="accessible_notes.docx",
            mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        )

    st.markdown("---")

    tabs = st.tabs(["Raw Transcript", "Accessible Notes"])

    with tabs[0]:
        st.subheader("Raw Transcript")
        st.write(raw_transcript)

    with tabs[1]:
        st.subheader("Accessible Notes (Markdown view)")
        st.write(accessible_transcript)

else:
    st.info("Upload an audio file above to generate both transcripts and downloadable notes.")
